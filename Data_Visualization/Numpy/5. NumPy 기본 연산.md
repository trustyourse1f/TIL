<!-- TOC -->

- [NumPy 기본 연산](#numpy-%EA%B8%B0%EB%B3%B8-%EC%97%B0%EC%82%B0)
    - [어레이의 산술 연산](#%EC%96%B4%EB%A0%88%EC%9D%B4%EC%9D%98-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0)
        - [예제](#%EC%98%88%EC%A0%9C)
    - [어레이의 곱 연산, 행렬곱 연산](#%EC%96%B4%EB%A0%88%EC%9D%B4%EC%9D%98-%EA%B3%B1-%EC%97%B0%EC%82%B0-%ED%96%89%EB%A0%AC%EA%B3%B1-%EC%97%B0%EC%82%B0)
        - [예제](#%EC%98%88%EC%A0%9C)
    - [어레이의 할당 연산](#%EC%96%B4%EB%A0%88%EC%9D%B4%EC%9D%98-%ED%95%A0%EB%8B%B9-%EC%97%B0%EC%82%B0)
        - [예제](#%EC%98%88%EC%A0%9C)
    - [Upcasting](#upcasting)
        - [예제](#%EC%98%88%EC%A0%9C)
    - [단항 연산 - sum, min, max](#%EB%8B%A8%ED%95%AD-%EC%97%B0%EC%82%B0---sum-min-max)
        - [예제](#%EC%98%88%EC%A0%9C)
    - [특정 축에 대한 연산 적용](#%ED%8A%B9%EC%A0%95-%EC%B6%95%EC%97%90-%EB%8C%80%ED%95%9C-%EC%97%B0%EC%82%B0-%EC%A0%81%EC%9A%A9)
        - [예제](#%EC%98%88%EC%A0%9C)

<!-- /TOC -->

# 5. NumPy 기본 연산
## 어레이의 산술 연산
어레이에 대한 산술 연산자는 요소 단위로 적용된다.  
새로운 어레이가 생성되어서 결과가 채워진다.

### 예제
```python
import numpy as np

a = np.array([20,30,40,50])
b = np.arange(4)

c = a-b
print(c)

print(b**2)
print(10*np.sin(a))
print(a<35)
```
```python
[20 29 38 47]
[0 1 4 9]
[ 9.12945251 -9.88031624  7.4511316  -2.62374854]
[ True  True False False]
```
`a-b` 와 같이 어레이의 차는 각 요소의 차를 갖는 어레이를 만든다.

`b**2` 과 같은 지수 연산이나 `np.sin(a)` 도 마찬가지로 요소 단위로 적용된다.

`a<35` 와 같은 비교 연산자의 경우에는 `True`, `False` 의 진리값을 갖는 어레이가 출력된다.

</br></br>

## 어레이의 곱 연산, 행렬곱 연산
다른 많은 행렬 언어와 다르게, NumPy 어레이에서 곱 (*) 연산은 요소 단위로 이루어진다.

일반적인 행렬곱 (matrix product)은 (Python > 3.5 에서) @ 연산자를 이용해서 하거나,

`dot()` 함수를 이용해서 수행할 수 있다.

### 예제
```python
import numpy as np

A = np.array([[1,1], [0,1]])
B = np.array([[2,0], [3,4]])

print(A * B)                    # elementwise product
print(A @ B)                    # matrix product
print(A.dot(B))                 # another matrix product
```
```
[[2 0]
 [0 4]]
[[5 4]
 [3 4]]
[[5 4]
 [3 4]]
```

</br></br>

## 어레이의 할당 연산
`+=`, `*=` 와 같은 연산들은 새로운 어레이를 만들지 않고 이전의 어레이를 대체하도록 동작한다.

### 예제
```python
import numpy as np

a = np.ones((2,3), dtype=int)
b = np.random.random((2,3))

a *= 3
print(a)

b += a
print(b)

a += b                  # b is not automatically converted to integer type
```
```python
[[3 3 3]
 [3 3 3]]
[[3.22121453 3.50794962 3.0809372 ]
 [3.60019017 3.16073469 3.27413715]]
Traceback (most recent call last):
  File "main.py", line 12, in <module>
    a += b                  # b is not automatically converted to integer type
numpy.core._exceptions.UFuncTypeError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'
```
`a += b` 연산에서 어레이 b가 자동으로 정수 타입의 어레이로 변환될 수 없어서 에러가 발생한다.

</br></br>

## Upcasting
다양한 타입을 갖는 어레이들의 연산 결과로 만들어지는 어레이의 타입은

더 일반적인 또는 더 정밀한 타입으로 결정 (upcasting)된다.

### 예제
```python
import numpy as np
from numpy import pi

a = np.ones(3, dtype=np.int32)
b = np.linspace(0,pi,3)
print(b.dtype.name)

c = a+b
print(c)
print(c.dtype.name)

d = np.exp(c*1j)
print(d)
print(d.dtype.name)
```
```python
float64
[1.         2.57079633 4.14159265]
float64
[ 0.54030231+0.84147098j -0.84147098+0.54030231j -0.54030231-0.84147098j]
complex128
```

</br></br>

## 단항 연산 - sum(), min(), max()
어레이의 모든 요소의 합을 계산하는 등의 단항 연산들은 ndarray 클래스의 메서드로 구현된다.

### 예제
```python
import numpy as np

a = np.random.random((2,3))
print(a)

print(a.sum())
print(a.min())
print(a.max())
```
```python
[[0.45970995 0.69712418 0.56494716]
 [0.200097   0.78456803 0.67355451]]
3.3800008264183745
0.20009699726571373
0.7845680273597524
```

</br></br>

## 특정 축에 대한 연산 적용
기본적으로 이러한 연산들은 shape에 관계없이 숫자의 리스트인 것처럼 어레이에 적용된다.

하지만 축 파라미터 (axis parameter)를 적용함으로써, 어레이의 특정 축에 대해 연산을 적용할 수 있다.

### 예제
```python
import numpy as np

b = np.arange(12).reshape(3,4)
print(b)

print(b.sum(axis=0))                            # sum of each column
print(b.min(axis=1))                            # min of each row
print(b.cumsum(axis=1))                         # cumulative sum along each row
```
```python
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[12 15 18 21]
[0 4 8]
[[ 0  1  3  6]
 [ 4  9 15 22]
 [ 8 17 27 38]]
```