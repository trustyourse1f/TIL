# 4장 데이터베이스와 아키텍처 구성

아키텍처는 '시스템을 만들기 위한 물리 레벨의 조합'의 의미  
구체적으로는 '어떤 기능을 가진 서버를 준비하고 어떠한 저장소나 네트워크 기기와 조합해서 시스템 전체를 만들 것인가' 즉 하드웨어와 미들웨어의 구성을 가리킨다.

아키텍처, 설계는 시스템 개발의 초반에 시행하는 일 중에서도 매우 중요한 일이다.  

데이터베이스에 관한 아키텍처의 역사는 구체적으로 다음 3단계로 나누어서 파악할 수 있다.
1. Stand-alone(~1980년대) - 데이터베이스만으로 시스템이 성립하는 가장 간단한 방법
2. 클라이언트/서버(1990년대~2000년) - 클라이언트와 서버로 계층을 분리하여 상호 간에 네트워크로 접속
3. Web 3계층(2000년~현재) - 클라이언트/서버를 더욱더 발전시킨 것

## Stand-alone
데이터베이스가 동작하는 머신(DB서버)이 LAN이나 인터넷 등의 네트워크에 접속하지 않고 '독립되어' 동작하는 구성  
이 구성에서는 데이터베이스의 미들웨어(DBMS)와 애플리케이션의 소프트웨어는 같은 DB서버에서 동작함  
데이터베이스를 사용하고 싶은 사용자는 DB서버가 설치된 장소까지 물리적으로 접근하여 서버 앞에 앉아서 데이터베이스를 사용하지 않으면 안 된다. 서버가 네트워크에 접속되어 있지 않아서 물리적으로 떨어진 장소에서 액세스하는 것도 불가능하다.  
- 단점 : 물리적으로 떨어진 장소에서 접근할 수 없다, 복수 사용자가 동시에 작업할 수 없다, 가용성이 낮다  
(시스템이 서비스 제공시간에 장애 없이 서비스를 계속 지속할 수 있는 비율이 어느 정도인가를 나타내는 개념을 가용성이라고 한다.)  
확장성이 부족하다
- 장점 : 구축이 매우 간단해서 소규모 작업이나 테스트를 빨리 할 수 있다, 보안이 매우 높다.

## 클라이언트/서버
데이터베이스를 네트워크에 연결함으로서 복수 사용자가 물리적으로 떨어진 장소에서 데이터베이스에 접속할 수 있게 됨  
데이터베이스 서버 1대에 복수 사용자의 단말이 접속하는 구성을 '클라이언트/서버'구성이라고 함. 시스템이 클라이언트와 서버의 2개 레이어(계층)로 구성되기 때문에 '2계층 구성'이라고 부르는 경우도 있음.  
DB서버에서는 DBMS가 동작하고 클라이언트에서는 업무 애플리케이션이 동작하는 분업체제로 볼 수 있다.  

## Web 3계층
- 클라이언트/서버 구성의 단점 : 인터넷에서 직접 데이터베이스에 접속하는 것에 대한 보안 위험, 불특정 다수의 사용자가 사용하는 클라이언트에서의 애플리케이션 관리비용이 많이 드는 점.  

Web 3계층은 시스템을 다음 3가지 계층의 조합으로 생각하는 모델
1. 웹 서버 계층
2. 애플리케이션 계층
3. 데이터베이스 계층

- 웹 서버 계층과 애플리케이션 계층  : 웹 서버는 클라이언트로부터 접속 요청(HTTP 요청)을 직접 받아서 그 처리를 뒷단의 애플리케이션 계층(애플리케이션 서버)에 넘기고 그 결과를 클라이언트에 반환한다. 즉, 애플리케이션 서버와 클라이언트 웹 브라우저와의 가교 역할. (ex.아파치, IIS 등)  
  애플리케이션 계층은 비즈니스 로직을 구현한 애플리케이션이 동작하는 층. 웹 서버로부터 연계된 요청을 처리하고 필요하면 데이터베이스 계층(DB 서버)에 접속해서 데이터를 추출하고 이를 가공한 결과를 웹 서버로 반환 (ex. Tomcat, WebLogic, WebSphere 등)

## 가용성을 높이는 2가지 전략
- 심장전략(고품질-소수전략) : 시스템을 구성하는 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제해서 가용성을 높인다  
- 신장전략(저품질-다수전략) : 시스템을 구성하는 각 컴포넌트의 신뢰성을 계속해서 높이기보다는 '사물은 언젠가 망가진다'란 체념을 전제로 여분을 준비해 둔다. 이를 철저히 대비하는 것을 '물량작전'이라고 부른다.  

## 클러스터
신장전략처럼 동일한 기능의 컴포넌트를 병렬화하는 것을 클러스터링이라고 부른다.  
클러스터는 시스템에서 '동일한 기능의 컴포넌트를 복수 개 준비해 한 개의 기능을 실현한다'는 의미로 사용한다.  
또한 클러스터 구성으로 시스템의 가동률을 높이는 것을 여유도를 확보한다 또는 '다중화'라고 지칭한다.

## 단일장애점
다중화되어 있지 않아서 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트를 단일 장애점이라고 한다.  
단일 장애점을 없애기 위해 대부분 이중화는 해두지만 그 이상 어느 정도 돈을 들여서 다중화할지는 예산 제약과 바라는 신뢰성 수준의 저울질에 달려 있다.  

데이터베이스에서 가용성을 높이는 기술은 '클러스터링'과 '리플리케이션'으로 크게 나눌 수 있다.   

## 클러스터링  
DB서버가 데이터를 보존하는 영속계층이기 때문에 웹 서버나 애플리케이션 서버와 비교하면 다중화에 대해 고민해야 할 부분이 많다.  
데이터베이스는 대량의 데이터를 영구적으로 보존해야 하고 그에 따른 성능도 요구되기 때문에 데이터를 보존하는 매체에 필요한 요건이 높다. 일반적으로 전용의 외부 저장소를 사용한다. 결국, DB 서버의 아키텍처는 저장소와 묶어서 생각해야 한다.  

DB서버가 2대 있지만 이 2대가 동시에 동작하는 것을 허락할지에 따라 'Active-Active'와 'Active-Standby'로 나뉜다.  
- Active-Active : 클러스터를 구성하는 컴포넌트를 동시에 가동한다.
- Active-Standby : 클러스터를 구성하는 컴포넌트 중 실제 가동하는 것은 Active, 남은 것은 대기(Standby)하고 있는다.  
###   Active-Active 구성
복수의 DB서버가 동시에 작동하고 있어서 한 대가 다운되어 동작 불능이 되도 남은 서버가 처리를 계속해 시스템 전체가 정지하는 것을 방지할 수 있다.  DB서버 대수가 증가하면 동시에 가동하는 CPU나 메모리도 증가하기 때문에 성능도 향상될 수 있다. 단 저장소가 병목이 되기 때문에 생각한 만큼 성능이 향상되지 않는 경우도 있다.

### Active-Standby 구성
보통 Standby 상태의 DB 서버는 사용되지 않다가 Active DB 서버에서 장애가 일어날 때만 사용된다. 이 때문에 전환될 때까지의 시차가 생기고 그사이 시스템은 서비스를 계속하는 것이 불가능한 다운 상태가 된다.
Active-Standby 구성은 다시 Cold-Standby와 Hot-Standby로 구분된다.  
- Cold-Standby : 평소에는 Standby DB가 작동하지 않다가 Active DB가 다운된 시점에는 작동하는 구성
- Hot-Standby : 평소에도 Standby DB가 작동하는 구성(높은 라이선스료) 

각 구성을 가용성과 성능이 좋은 순으로 정리하면 다음과 같고(성능 관점에서는 Hot-Standby와 Cold-Standby 사이에는 차이가 없다) 이 순서는 라이선스료의 가격순이다.
1. Active-Active
2. Active-Standby(Hot-Standby)
3. Active-Standby(Cold-Standby)

## 리플리케이션
Active-Active와 Active-Standby 클러스터 구성에는 서버 부분은 다중화할 수 있어도 저장소 부분은 다중화할 수 없어서 데이터를 다중화하지 않는 공통적인 단점이 있다. 즉, 저장소가 부서질 경우에는 데이터를 잃게 된다.  
이런 상황에 대응하기 위한 클러스터 구성이 리플리케이션(복제)이다. 이는 DB서버와 저장소 세트를 복수로 준비하는 것을 말한다.  
리플리케이션은 데이터베이스 서버와 저장소가 동시에 사용 불능일 때 다른 1세트가 멀리 떨어진 지점에 놓여 있다면 서비스를 계속하는 것이 가능하다는 점에서 매우 가용성이 높은 아키텍처이다.   
- 리플리케이션에서 주의할 점 :   
  리플리케이션에서 중요한 점은 Active측 저장소의 데이터는 항상 사용자로부터 갱신된다는 것. 이 때문에 Standby측 데이터에도 갱신을 반영하여 최신화하지 않으면(동기화 작업) Active측과의 데이터 정합성을 유지할 수 없다. Active측 DB서버에서 갱신된 데이터를 일정 주기로 Standby측 DB서버에 써 내려 간다. 이때 Standby측의 갱신 주기를 얼마로 할 것인가와 성능 사이에 트레이드오프 관계가 생긴다.  

## 성능을 추구하기 위한 다중화 - Shared Nothing
Active-Active 구성의 DB는 저장소 부분이 병목되는 경우가 있다. 이것은 복수의 서버가 1대의 디스크(저장소)를 공유하도록 구성되었기 때문에 일어나는 문제이다. 이렇게 복수의 서버가 1개의 디스크를 사용하는 구성을 Shared Disk라고 부른다.  
Shared Disk 타입의 Active-Active구성은 저장소를 쉽게 늘리기 어렵고 DB서버 대수가 증가할수록 DB서버간의 정보공유를 위한 오버헤드가 크기 때문에 DB서버를 늘려도 무한으로 처리율이 향상되지 않는다. 이 단점을 극복하기 위한 아키텍처로 고안된 것이 Shared Nothing이다.  
Shared Nothing은 네트워크 이외의 자원을 모두 분리하는(아무것도 공유하지 않는)방식이다. 서버와 저장소의 세트를 늘리면 병렬처리 때문에 선형적으로 성능이 향상되는 장점이 있다. DB서버와 저장소의 세트를 늘려서 저장소가 병목이 되는 것을 방지하고 있어서 이 세트에 비례해서 처리율이 증가한다는 이점을 얻을 수 있다.  
그러나 저장소를 공유하지 않는 것은 결국 각각의 DB서버가 동일한 1개의 데이터에 엑세스할 수 없다란 것을 의미한다.  


아키텍처를 만드는 데는 그에 따른 비용과 작업이 필요하므로 트레이드오프가 발생한다.ㄴ